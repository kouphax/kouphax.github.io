<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="SPAs and Enabling CORS in Spark" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>SPAs and Enabling CORS in Spark</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">SPAs and Enabling CORS in Spark</h1><div class="post" itemprop="articleBody"><p>Having been tinkering with <a href="http://sparkjava.com">Spark</a> again I needed to build a simple bit of infrastructure for building single page applications that could be deployed anywhere. I also needed to potentially support CORS (Cross Origin Resource Sharing) so that remote client-side JavaScript applications could actually access the JSON API aspect of the solution. Doing this with Spark is pretty simple but I thought I'd document the process to avoid some people (or future me) having to answer the same questions again. I'm going to assume you know a bit about Spark, if not have a skim of the <a href="http://sparkjava.com/readme.html">README</a> on the site.</p><h2>Building a SPA</h2><p>An SPA or Single Page Application is an application that serves a single HTML page and included JavaScript on that page is responsible for dealing with talking to the server, getting data, rendering different views and handling view navigation. This is different from the traditional approach of rendering views on the server through the typical request/response lifecycle. I'm not going to debate the merits and drawbacks of either strategy in this post let's just assume that you've decided to go with an SPA in a Java context and you want something simple. I'm also not going to suggest any sort of front-end framework here - that'll depend on what you need, right? So a sample anatomy of an SPA could look like this,</p>
<ul>
  <li>The root path at <code>http://website/</code> returns a static <code>index.html</code> file</li>
  <li>The <code>index.html</code> file loads the necessary static assets such as JavaScript and CSS</li>
  <li>The JavaScript calls local API endpoints to load data<a name="_1"></a><a href="#1"><sup>1</sup></a> and render content through client side templates or straightforward DOM manipulation</li>
</ul><p>That's it. So in Spark to support these needs you need to do a few things,</p><h2>The API endpoints</h2><p>JavaScript loves JSON, it makes sense. So we need to create an API endpoint that returns JSON responses.</p>
<pre class="highlight"><code class="java"><span class="n">get</span><span class="o">(</span><span class="k">new</span> <span class="n">JsonRoute</span><span class="o">(</span><span class="s">"/api"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Request</span> <span class="n">request</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{{</span>
            <span class="n">put</span><span class="o">(</span><span class="s">"message"</span><span class="o">,</span> <span class="s">"Hello World"</span><span class="o">);</span>
        <span class="o">}};</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre><p>This stubbed route simply returns a map of key value pairs. If you look at the route type (<code>JsonRoute</code>) you'll notice it's not a typical Spark route type. In fact it's a class implemented by me. <code>JsonRoute</code>, we'll look at the code shortly, makes use of a Spark class - <code>ResponseTransformerRoute</code> which is a specialized route type that supports the ability to "transform" the returned response model (the object that get returned by the routes handle method). In this implementation, below, I'm simply passing the model into a Jackson <code>ObjectMapper</code>,</p>
<pre class="highlight"><code class="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">JsonRoute</span> <span class="kd">extends</span> <span class="n">ResponseTransformerRoute</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectMapper</span><span class="o">();</span>

    <span class="kd">protected</span> <span class="nf">JsonRoute</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
       <span class="kd">super</span><span class="o">(</span><span class="n">path</span><span class="o">,</span> <span class="s">"application/json"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">render</span><span class="o">(</span><span class="n">Object</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">model</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
 <span class="o">}</span>
</code></pre><p>This allows us to abstract out the process of transforming API responses into JSON and serving the correct response type as well. Yep I could have done this directly in my route declaration but I like to keep the main entry point for my application clean and readable as that's where most people will start to reason about how the application behaves. So that gives us a nice API endpoint. We can access this by running the application and hitting <code>http://locahost:4567/api</code>.</p><h2>Serving Static Assets</h2><p>Next up we want to be able to support serving the JavaScript, CSS and HTML that makes up our non-api aspects of our solution. Spark makes this easy</p>
<pre class="highlight"><code class="java"><span class="n">staticFileLocation</span><span class="o">(</span><span class="s">"/public"</span><span class="o">);</span>
</code></pre><p>This command (declared in the main method) will wire up a handler to serve resources that are stored in <code>src/main/resources/public</code> as static files. You can also specify external files (outside the built jar for example) but I've went with resources in this example. Then we create an index.html page in this folder along with some JavaScript and CSS,</p>
<pre class="highlight"><code class="java"><span class="o">&lt;!</span><span class="n">doctype</span> <span class="n">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">title</span><span class="o">&gt;</span><span class="n">Template</span><span class="o">&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">link</span> <span class="n">rel</span><span class="o">=</span><span class="s">"stylesheet"</span> <span class="n">href</span><span class="o">=</span><span class="s">"/css/styles.css"</span><span class="o">/&gt;</span>
    <span class="o">&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">h1</span> <span class="n">id</span><span class="o">=</span><span class="s">"css-broken-warning"</span><span class="o">&gt;</span><span class="n">The</span> <span class="n">stylesheet</span> <span class="n">didn</span><span class="err">'</span><span class="n">t</span> <span class="n">load</span> <span class="n">or</span> <span class="n">something</span><span class="o">,</span> <span class="n">maybe</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">Template</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">script</span> <span class="n">type</span><span class="o">=</span><span class="s">"text/javascript"</span> <span class="n">src</span><span class="o">=</span><span class="s">"/js/app.js"</span><span class="o">&gt;&lt;/</span><span class="n">script</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>
</code></pre><p>The CSS file in this case hides the CSS Broken Banner to prove this works</p>
<pre class="highlight"><code class="css"><span class="nf">#css-broken-warning</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
<span class="p">}</span>
</code></pre><p>And the JavaScript simply appends a new H2 node to the document, again just to prove the whole thing works.</p>
<pre class="highlight"><code class="javascript"><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">element</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">"h2"</span><span class="p">);</span>
    <span class="nx">element</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">"JavaScript Works"</span><span class="p">;</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">"body"</span><span class="p">).</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
<span class="p">}(</span><span class="nb">document</span><span class="p">))</span>
</code></pre><p>You'll rip these dummy files out when you actually being to write your app and it's better to write test for this sort of thing generally.</p><p>We can run the app again and browse to <code>http://localhost:4567/index.html</code> and make sure everything works.</p><h2>Serving the Root</h2><p>If you go to the root URL right now (<code>http://localhost:4567/</code>) you see that we still haven't satisfied the first condition of our SPA structure, we need to navigate to the index.html page specifically to see the app in action. To support the route URL serving the <code>index.html</code> file we can use a Spark before filter.</p>
<pre class="highlight"><code class="java"><span class="n">before</span><span class="o">(</span><span class="k">new</span> <span class="n">Filter</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Request</span> <span class="n">request</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/public/index.html"</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">halt</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="n">IOUtils</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">stream</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// if the resource doesn't exist we just carry on.</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre><p>The filter, locked down to the <code>/</code> route checks for the index.html resource and spits its contents out via a halt call (stop processing filters and handlers for this route). If it doesn't find it it just passed responsibility to the remaining filters and handlers. But why a filter? Well you could use a route and do something similar,</p>
<pre class="highlight"><code class="java"><span class="n">get</span><span class="o">(</span><span class="k">new</span> <span class="n">Route</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Request</span> <span class="n">request</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="n">InputStream</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/public/index.html"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">IOUtils</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">stream</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre><p>But I think the filter is a bit neater. I the route case we have to return something. We can't just pass on to the next handler so instead we throw which may not make sense in all cases. Again it comes down to need here and YMMV so you now have 2 approaches to do the same thing. So running the app and hitting <code>http://localhost:4567/</code> gives use our SPA infrastructure in place.</p><h2>CORS</h2><p>Supporting CORS in any web framework is a matter of Header manipulation - if you can do that you're sorted. Spark is no exception. CORS can be configured in a few different ways, you can set a few different types of headers, specify different header values etc. The example I provide here aims to give you a bit of configurability but uses it in the most permissive way possible (allowing any origins, header values and HTTP methods).</p>
<pre class="highlight"><code class="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">enableCORS</span><span class="o">(</span><span class="kd">final</span> <span class="n">String</span> <span class="n">origin</span><span class="o">,</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">methods</span><span class="o">,</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">headers</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">before</span><span class="o">(</span><span class="k">new</span> <span class="n">Filter</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">Request</span> <span class="n">request</span><span class="o">,</span> <span class="n">Response</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">response</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Access-Control-Allow-Origin"</span><span class="o">,</span> <span class="n">origin</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Access-Control-Request-Method"</span><span class="o">,</span> <span class="n">methods</span><span class="o">);</span>
            <span class="n">response</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Access-Control-Allow-Headers"</span><span class="o">,</span> <span class="n">headers</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre><p>This method, which should be called early and called once in the main method, attaches a Spark filter to every route (you should alter that to your needs) that sets the necessary CORS headers to the passed in values. We can call this from the main method like this,</p>
<pre class="highlight"><code class="java"><span class="n">enableCORS</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="s">"*"</span><span class="o">,</span> <span class="s">"*"</span><span class="o">);</span>
</code></pre><p>Which is as open as possible (more than it needs to be in most cases) for remote clients. You can test this using <a href="http://client.cors-api.appspot.com/client">test-cors.org</a> on your local instance.</p><p>Now we have a simple CORS enabled setup to build you SPAs using the wealth of technologies that Java offers.</p>
<hr /><p><sup><a name="1"></a><a href="#_1">1</a>: You could, if you desired, return HTML snippets, or JS commands rather than data but for the purposes of this post lets assume an API as this a lot nicer when supporting 3rd party apps that want to integrate - DATA IS KING and all that.</sup></p><sup></sup></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2014%2F02%2F20%2Fspas-and-enabling-cors-in-spark%2F&amp;text=SPAs%20and%20Enabling%20CORS%20in%20Spark&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="20-02-2014" itemprop="datePublished">February 20, 2014</time></div><div class="categories">Published in <a href="/categories/java/">Java</a> on February 20, 2014</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19143623-5', 'yobriefca.se');
  ga('send', 'pageview');</script></body></html>