<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Managing Environment Variables in Clojure" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Managing Environment Variables in Clojure</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Managing Environment Variables in Clojure</h1><div class="post" itemprop="articleBody"><blockquote><p>If you've never read the <a href="http://12factor.net/">Twelve Factor App</a> methodology I strongly recommend you do, it's a great guide born from real life experience of building many, many web applications.</p>
</blockquote><p>One of the rules in the <a href="http://12factor.net/">Twelve Factor App</a> methodology is that you <a href="http://12factor.net/config">"Store config in the environment"</a> or, more specifically, store config that is likely to change <strong>across environments</strong> in the environment. It makes sense as it ties the target environment and its necessary configuration together instead of having to juggle <code>if ENV=test|dev</code> style flags around your code base or swap out different config files per build.</p><p>One other positive side effect of this approach is that secure configuration doesn't accidentally get checked into source. Every one needs database credentials or client secrets but no-one want to share them with the world.</p><p>Supporting this approach in Clojure is fairly simple and there are a few ways to do it.</p><h2>System/getenv</h2><p>Clojure sits on the JVM and the JVM has the <code>System</code> namespace which provides utilities and classes for accessing the running systems features. <code>System.getenv</code> and <code>System.getenv(String)</code> give us access to environment variables from Clojure.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">System/getenv</span> <span class="s">"DATABASE_URL"</span><span class="p">)</span>
<span class="c1">;=&gt; http://user:pass@dburl/mydb</span>
</code></pre><p>We can also provide a fallback for environment variables that don't exist</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">System/getenv</span> <span class="s">"NOEXIST_DATABASE_URL"</span><span class="p">)</span>
    <span class="s">"http://localhost/mydb"</span><span class="p">)</span>
<span class="c1">;=&gt; http://localhost/mydb</span>
</code></pre><p>In this case <code>NOEXIST_DATABASE_URL</code> isn't set as an environment variable so we fallback to our hardcoded version. </p><p>This isn't uncommon and often its done to support development environments. For example <a href="http://heroku.com">Heroku</a> (where the original 12 factor app methodology arose) add environment variables for any addons you may activate such as <code>DATABASE_URL</code> for the Postgres DB addon. So rather than write different handlers per environment many people would either.</p>
<ol>
  <li>Use the fallback URL to represent their development environment</li>
  <li>Add the environment variable to their shell</li>
</ol><p>Both of the approaches have problems. Using a fallback URL can lead to problems where an environment isn't correctly configured and starts using the wrong database. If it can write to it there will be trouble, if it can't you'll be scratching your head wondering whats going wrong for longer then necessary. Setting a project specific environment variable in your shell can lead to pain when things get overwritten across projects and pollution if you're setting it in an automated fashion (<code>.bashrc</code>) or you'll simply forget to set it per use when doing it manually.</p><h2>weavejester/environ</h2><p>A neater solution is available in the form of <a href="https://github.com/weavejester/environ"><code>environ</code></a> - a simple library for managing environment variables. The clever thing <a href="https://github.com/weavejester/environ"><code>environ</code></a> does is merge environment variables from multiple sources into a single map.</p><p>So by adding it to our <code>project.clj</code></p>
<pre class="highlight"><code class="clojure"><span class="p">[</span><span class="nv">environ</span> <span class="s">"0.5.0"</span><span class="p">]</span>
</code></pre><p>We can import and use it where we need,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">require</span> <span class="p">[</span><span class="nv">environ.core</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">env</span><span class="p">]])</span>

<span class="p">(</span><span class="nf">env</span> <span class="ss">:database-url</span><span class="p">)</span>
<span class="c1">;=&gt; http://localhost/mydb</span>
</code></pre><p>So how are the environment variables sourced? Well environ looks in a number of areas in order,</p>
<ol>
  <li>A <code>.lein-env</code> file in the project directory</li>
  <li>Environment variables</li>
  <li>Java system properties</li>
</ol><p>It also keywordises the variable names as you can see from the example above.</p><p>Great, so why is this more useful? The big benefit I've discovered is the <code>.lein-env</code> file in the root of my project. This file holds a map of environment values that can be useful during development. There are 2 ways to create this file.</p>
<ol>
  <li>The RIGHT way as set out by the creator of the project, and,</li>
  <li>The WRONG way as in how I use it</li>
</ol><p><code>environ</code> also has a plugin available <code>lein-environ</code> which sucks profile specific settings from <code>~/.lein/profiles.clj</code> and/or a project specific <code>profiles.clj</code> (which should not be checked into source) and creates the <code>.lein-env</code> file when Leiningen does its thing (effectively making <code>.lein-env</code> a transient file). A <code>.lein-env</code> file looks a little something like this.</p>
<pre class="highlight"><code class="clojure"><span class="p">{</span> <span class="ss">:env</span> <span class="p">{</span> <span class="ss">:database-url</span> <span class="s">"http://localhost/mydb"</span>
         <span class="ss">:client-token</span> <span class="s">"QWERTY12345"</span> <span class="p">}</span> <span class="p">}</span>
</code></pre><p><strong>Caveat:</strong> Now you <strong>can</strong> create this manually (this is what I have done for a small project I'm working on) but it's not officially recommended for a few reasons. Firstly the minute you add the <code>lein-environ</code> plugin to the project your important setting will get wiped out and secondly you lose out on the ability to vary setting across profiles as well that you'd get from <code>profiles.clj</code>. </p>
<blockquote><p>Big thanks to <a href="https://twitter.com/weavejester">@weavejester</a> the creator of <code>environ</code> for the tip off about my dubious use of <code>.lein-env</code></p>
</blockquote><p>So back to <code>.lein-env</code> - You end up with the <code>.lein-env</code> file on your machine with development (or profile) specific values and you forget about fallbacks and setting environment variables and the potential conflicts with other projects. Then on your production and test systems you can source values from actual environment variables without having to change your strategy or use <code>(if (= "test" (:env config)))</code> style checks.</p><p>Its worth noting that <code>.lein-env</code> is already added as a match in the default <code>.gitignore</code> from <code>lein new ...</code> so wont be checked into <code>git</code> - <strong>BUUUUUUT...</strong> if you do manage to check in and push your <code>.lein-env</code> file (or any project specific <code>profiles.clj</code> file) and it does happen to contain secure tokens and passwords (hashed or otherwise) you must assume those values are already compromised even if you manage to purge them from history.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2014%2F04%2F29%2Fmanaging-environment-variables-in-clojure%2F&amp;text=Managing%20Environment%20Variables%20in%20Clojure&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="29-04-2014" itemprop="datePublished">April 29, 2014</time></div><div class="categories">Published in <a href="/categories/clojure/">Clojure</a> on April 29, 2014</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
