<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Why Scala? Because C#" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Why Scala? Because C#</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Why Scala? Because C#</h1><div class="post" itemprop="articleBody"><blockquote><p>Strange as it may sound this isn't a post about promoting the adoption of Scala but if its a conversation you're already having there may be some points here that might help. I often hear rationale for Scala over Java based around the functional style, immutability and slightly better concurrency model baked in but I've always found there is a simpler point to be made. Time will tell wether the recent release of Java 8 will add enough to old faithful to slow the adoption of Scala.</p>
</blockquote><p>I often get asked by people I'm introducing to Scala, "Why Scala and why not Java" and more often that not the topic turns to comparisons between Scala and C#. Its not just me either. Last year I was involved in a few rounds of procurement, interviewing prospective IT companies and team and a common pattern that came out of those interviews was people would be offering us teams composed of their C# developers over their Java developers. Scala experience was, at that time, still a bit light on the ground and yes you could argue that the general trend toward fully open source stacks in many markets was squeezing the amount of available work for MS folks but the message most people delivered was their C# developers were generally more capable of transitioning to Scala than their Java people. I can't necessarily dispute this either because I certainly feel my background in C# helped me ramp up on my first Scala project much faster than my Java experience had.</p><p>Allow me a little example (ripped right out of my <a href="https://speakerdeck.com/kouphax/scala-for-c-number-developers">Scala for C# Developers</a> talk)</p>
<pre class="highlight"><code class="scala"><span class="s">"CHRISTMAS"</span><span class="o">.</span><span class="n">makeChristmasy</span>
<span class="c1">// =&gt; ***CHRISTMAS***</span>
</code></pre><p>There are three important things to know here</p>
<ol>
  <li>The <code>String</code> class in Java is <code>final</code> and can't be extended.</li>
  <li>The <code>String</code> class in Scala is <code>final</code> and can't be extended (it is the Java <code>String</code> class)</li>
  <li>The <code>String</code> class in C# is <code>sealed</code> and can't be extended</li>
</ol><p>Yet we just called a function on it that isn't part of Strings signature (it's common knowledge Scala has a lot of bells and whistles but trust me the String class doesn't normally have a <code>makeChristmasy</code> method)</p><p>To implement this we can make use of Scalas <a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">Implicit Classes</a>. We can write a class that wraps a class, <code>String</code> in our case, </p>
<pre class="highlight"><code class="scala"><span class="k">implicit</span> <span class="k">class</span> <span class="nc">FancyString</span><span class="o">(</span><span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
 <span class="k">def</span> <span class="n">makeChristmasy</span> <span class="k">=</span> <span class="s">"***"</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"***"</span>
<span class="o">}</span>
</code></pre><p>Import this into our namespace and voila our <code>String</code> variables and values have the <code>makeChristmasy</code> method available to them. Under the hood the Scala compiler is auto wrapping the String instances with FancyString where necessary. Kinda like this,</p>
<pre class="highlight"><code class="scala"><span class="k">new</span> <span class="nc">FancyString</span><span class="o">(</span><span class="s">"CHRISTMAS"</span><span class="o">).</span><span class="n">makeChristmasy</span>
</code></pre><p>Sure its essentially a bit of syntactic sugar but it can, when used wisely, help make code clearer.</p><p>C# can do this too. C# has extension methods,</p>
<pre class="highlight"><code class="csharp"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">FancyString</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">MakeChristmasy</span><span class="p">(</span><span class="k">this</span> <span class="n">String</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"***"</span> <span class="p">+</span> <span class="n">s</span> <span class="p">+</span> <span class="s">"***"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><p>So what? Scala has a feature that C# has and Java doesn't. Hell lets do the same in Ruby,</p>
<pre class="highlight"><code class="ruby"><span class="k">class</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="nf">make_christmasy</span>
    <span class="s2">"***</span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">***""</span>
<span class="s2">  end  </span>
<span class="s2">end </span>
</code></pre><p>So now can Ruby developers transition to Scala faster than Java devs? No, well maybe I'm not sure, stop confusing me, besides open classes in Ruby are a vastly different and scarier thing than extension methods and implicit classes.</p><h2>Your point being...?</h2><p>There is a certain power and flexibiltiy that a feature like implicits offer. An ability to coerce the underlying language into something that makes more sense in the given context. Yeah its open for abuse but we're supposed to be grown ups here people. Lets not force people to use plastic knives to cut steak just in case they stab themselves. Of course its not just implicits - the language is simply a richer language.</p><p>What Scala offers is somewhat like C# on the JVM. Java fell behind C# a long time ago and even with the release of Java 8 it is still not quite there. There is a degree of expressiveness in C# that enabled me in my .NET days to produce better, more grokable systems in C# than anything I produced in Java. I found the same with Scala. Sure there are many, many dark corners in Scala but they can be avoided be that through a common understanding, peer review, automated checks like Sonar or even through the use of Scalas in-progress ability to add/remove language features through modular design. <a href="http://www.thoughtworks.com/radar/#/languages-and-frameworks/257">"Scala: The Good Parts"</a> as Thoughtworks termed it in their tech radar is a theoretical subset of the language that offers better collection support, terser syntax and a reduction in the need for pattern boilerplate without having to upgrade your JVM.</p><p>So while the gap between Java and Scala has lessened it's still there and given the cycle time for new Java releases it's not going to shorten any time soon. Perhaps you think there are times when you want your language to be a constraint on your team. I'd be suprised if you've never encountered a room full of mad language scientists trying to golf some operation down to 3 convoluted lines because "FUNCTIONAL PROGRAMMING YAY". But imposing artificial constraints because of a team problem is just going to frustrate the "good" people and frankly instead of an unmaintainable mess due to bonkers code golf you'll probably get an unmaintainable mess due to over application of EVERY PATTERN BECAUSE OBJECTS!</p><p>So why Scala? Because there is a core feature set in the language that enables people to produce nice clean straightforward code with less boilerplate and enough power and flexibility to make the intent of the resulting code clearer. Like C#.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2014%2F04%2F03%2Fwhy-scala-because-c-number%2F&amp;text=Why%20Scala%3F%20Because%20C%23&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="03-04-2014" itemprop="datePublished">April 03, 2014</time></div><div class="categories">Published in <a href="/categories/scala/">Scala</a> on April 03, 2014</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
