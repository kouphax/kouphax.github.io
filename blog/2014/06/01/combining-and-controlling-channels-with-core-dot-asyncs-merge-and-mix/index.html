<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Combining &amp; Controlling Channels with core.async&apos;s merge and mix" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Combining & Controlling Channels with core.async's merge and mix</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Combining & Controlling Channels with core.async's merge and mix</h1><div class="post" itemprop="articleBody"><p>Most discussions around <a href="https://github.com/clojure/core.async"><code>core.async</code></a>, be it in Clojure or ClojureScript, tend to focus around the key concepts of the library - specifically <code>chan</code>s and the <code>go</code>/<code>go-loop</code> macros. This isn't a bad thing as that is were the power of the library comes from, on the other hand <a href="https://github.com/clojure/core.async"><code>core.async</code></a> also has a few powerful higher-level features that let you do some very interesting things and they deserve a bit of love as well.</p><p>Two such features are <a href="http://clojure.github.io/core.async/#clojure.core.async/merge"><code>merge</code></a> and <a href="http://clojure.github.io/core.async/#clojure.core.async/mix"><code>mix</code></a>. Both methods have a similar goal - combining multiple input channels into a single output channel however in practise they are rather different.</p><p>At a high level you could draw the 2 operations like so,</p><p><img src="/images/blog/mix-merge.png" alt="High level view of merge and mix" _="_" /></p><p>In fact the <code>mix</code> diagram is slightly more complicated in reality but we can expand on that as we go.</p><h2>Setting up</h2><p>So lets look at some examples of these operations. I'm talking in the context of ClojureScript in this case but same reules and principles apply in plain Clojure.</p><p>If you want to try these examples and are rather new to ClojureScript I recently outlined a <a href="http://yobriefca.se/blog/2014/05/30/basic-clojurescript-setup/">basic ClojureScript setup</a> which will get you up and running.</p><p>Assuming you have an empty ClojureScript project one way or another you need to add a reference to <code>core.async</code> in the <code>:dependencies</code> section of the projects <code>project.clj</code></p>
<pre class="highlight"><code class="clojure">  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojurescript</span> <span class="s">"0.0-2173"</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">org.clojure/core.async</span> <span class="s">"0.1.303.0-886421-alpha"</span><span class="p">]]</span>
</code></pre><p>Then in your ClojureScript source (probably <code>src/&lt;project_name&gt;/core.cljs</code>) you need to import a few things. I'll assume you have at least a basic understanding of channels and <code>core.async</code> already so we can just import everything we need for the examples.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">chat.core</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">cljs.core.async</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">mix</span> <span class="nv">admix</span> <span class="nv">toggle</span> <span class="nb">merge </span><span class="nv">chan</span> <span class="nv">&lt;!</span> <span class="nv">&gt;!</span> <span class="nv">timeout</span><span class="p">]])</span>
  <span class="p">(</span><span class="ss">:require-macros</span> <span class="p">[</span><span class="nv">cljs.core.async.macros</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">go</span><span class="p">]]))</span>
</code></pre><p>Now we are about ready for the examples.</p><h2><a href="http://clojure.github.io/core.async/#clojure.core.async/merge"><code>merge</code></a></h2><p><code>merge</code> is the simpler of the two features and as the API documentation says combines 1..N source channels and returns a channel which contains all values taken from them. The operation is entirely immutable. That is, once you use <code>merge</code> to create a channel you can't add or remove channels later. When all input channels have closed the merged channel will also close.</p><p>This is useful when you have multiple event streams, represented as channels, and you want to process them in the same way and in a centralised manner e.g. when you are wanting to parse multiple simultaneous server requests, web socket events or user interactions from various parts of the user interface.</p><p>To keep the example simple we will just create 3 channels that randomly publish their names every now and then,</p>
<pre class="highlight"><code class="clojure"><span class="c1">; declare the channels</span>
<span class="p">(</span><span class="k">def </span><span class="nv">in-channel-one</span>   <span class="p">(</span><span class="nf">chan</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">in-channel-two</span>   <span class="p">(</span><span class="nf">chan</span><span class="p">))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">in-channel-three</span> <span class="p">(</span><span class="nf">chan</span><span class="p">))</span>

<span class="c1">; define the function for publishing</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">randomly-constantly</span>
  <span class="s">"Constantly publishes the given value to the given channel in random</span>
<span class="s">   intervals every 0-5 seconds."</span>
  <span class="p">[</span><span class="nv">channel</span> <span class="nv">publish-value</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
        <span class="p">(</span><span class="nf">&lt;!</span> <span class="p">(</span><span class="nf">timeout</span> <span class="p">(</span><span class="nb">* </span><span class="mi">1000</span> <span class="p">(</span><span class="nb">rand-int </span><span class="mi">5</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">&gt;!</span> <span class="nv">channel</span> <span class="nv">publish-value</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">recur</span><span class="p">))))</span>

<span class="c1">; start putting stuff on the channels</span>
<span class="p">(</span><span class="nf">randomly-constantly</span> <span class="nv">in-channel-one</span>   <span class="s">"channel-one"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">randomly-constantly</span> <span class="nv">in-channel-two</span>   <span class="s">"channel-two"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">randomly-constantly</span> <span class="nv">in-channel-three</span> <span class="s">"channel-three"</span><span class="p">)</span>
</code></pre><p>So now we have 3 channels that will randomly have their name pushed onto them we now need to do something with them. For the sake of simplicity lets assume all we need to do is log the result. We could write 3 distinct <code>go</code> loops (or suitably abstract it into a reusable function),</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">in-channel-one</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">in-channel-two</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">in-channel-three</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>
</code></pre><p>But regardles of how much you abstract away the mechanics you are still dealing with the 3 channels as 3 distinct entities when in many cases you should be dealing with a single channel derived from multiple sources. We achieve this with <code>merge</code></p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">merged</span> <span class="p">(</span><span class="nb">merge </span><span class="p">[</span><span class="nv">in-channel-one</span>
                    <span class="nv">in-channel-two</span>
                    <span class="nv">in-channel-three</span><span class="p">]))</span>
</code></pre><p><code>merged</code> is now a channel that we can <code>take</code> from and recieve values from all 3 channels. Now we can perform our <code>go</code> loop over the single channel instead,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">merged</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>
</code></pre><h2><a href="http://clojure.github.io/core.async/#clojure.core.async/mix"><code>mix</code></a></h2><p><code>merge</code> is fine when you want to just grab a bunch of channels and treat them as one but sometimes this is not enough. When it comes to channels that produce effects visible to the user there is often a need to better control these messages. Imagine a chat application where each person is represented as a channel, or perhaps a log dashboard where each channel is a service in your system streaming log data.</p><p>In such situations, where the volume is high, there may be times you want to focus on a particular set of logs or chat messages, or surpress someone or something that is being particularly chatty. Maybe these messages can be discarded, maybe they are important and need to looked at later. These are the things that <code>merge</code> fails to address. These are the things that <code>mix</code> <strong>does</strong> address.</p><p>The key differences that set <code>mix</code> apart from <code>merge</code> are that,</p>
<ul>
  <li>It introduces an intermediary component - the mixer</li>
  <li>It is configurable, you can add and remove input channels</li>
  <li>Channels can be muted, paused and solo'ed on demand</li>
</ul><p>So lets take our 3 channels above and apply the abilities of <code>mix</code> to the situation.</p><p>First of all we need to create 2 things.</p>
<ol>
  <li>The output channel - unlike <code>merge</code> this isn't created for us</li>
  <li>The mixer - we create this via the <code>mix</code> method</li>
</ol>
<pre class="highlight"><code class="clojure"><span class="c1">; manually declare our output channel</span>
<span class="p">(</span><span class="k">def </span><span class="nv">output-channel</span> <span class="p">(</span><span class="nf">chan</span><span class="p">))</span>

<span class="c1">; create a mixer linked to the output channel</span>
<span class="p">(</span><span class="k">def </span><span class="nv">mixer</span> <span class="p">(</span><span class="nf">mix</span> <span class="nv">output-channel</span><span class="p">))</span>
</code></pre><p>We can also, at this point, set up our <code>go</code> loop for printing the data put onto the output channel</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">go</span> <span class="p">(</span><span class="k">loop </span><span class="p">[]</span>
      <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">output-channel</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>
</code></pre><p>Unlike <code>merge</code> we still haven't declared what input channels should be associated with the mixer and ultimately output channel. We can do this using <a href="http://clojure.github.io/core.async/#clojure.core.async/admix"><code>admix</code></a>,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">admix</span> <span class="nv">mixer</span> <span class="nv">in-channel-one</span><span class="p">)</span>
<span class="p">(</span><span class="nf">admix</span> <span class="nv">mixer</span> <span class="nv">in-channel-two</span><span class="p">)</span>
<span class="p">(</span><span class="nf">admix</span> <span class="nv">mixer</span> <span class="nv">in-channel-three</span><span class="p">)</span>
</code></pre><p>At this point we should start seeing stuff being logged to the console exactly like we did with <code>merge</code>. This is where <code>mix</code> starts to get interesting.</p><h3><a href="http://clojure.github.io/core.async/#clojure.core.async/toggle"><code>toggle</code></a></h3><p><code>toggle</code> allows you to control how the mixer responds to each input channel. You pass it a state map of channels and associated mixer properties. With <code>toggle</code> you can do any combination (though many would not make sense) of,</p>
<ul>
  <li><code>:mute</code> - keep taking from the input channel but discard any taken values</li>
  <li><code>:pause</code> - stop taking from the input channel</li>
  <li><code>:solo</code> - listen <strong>only</strong> to this (and other <code>:solo</code>ed channels). Whether or not the non-soloed channels are muted or paused can be controlled via the <a href="http://clojure.github.io/core.async/#clojure.core.async/solo-mode"><code>solo-mode</code></a> method.</li>
</ul><p>So lets imagine one of our mixed channels (<code>in-channel-one</code>) it getting a bit chatty. It could swamp our logging output and we might miss something important in another channel. We can use toggle to temporarily mute it,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">toggle</span> <span class="nv">mixer</span> <span class="p">{</span>  <span class="nv">in-channel-one</span> <span class="p">{</span> <span class="ss">:mute</span> <span class="nv">true</span> <span class="p">}</span> <span class="p">})</span>
</code></pre><p>Now our output will only be displaying the other 2 channels. But suppose the data coming in from channel one was actually important, as it stands muting a channel simply discards any takes that happen. If we want to stop taking anything from the channel (and therefore allow it to buffer on the channel) we can pause the channel instead.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">toggle</span> <span class="nv">mixer</span> <span class="p">{</span> <span class="nv">in-channel-one</span> <span class="p">{</span> <span class="ss">:mute</span>  <span class="nv">false</span>
                                 <span class="ss">:pause</span> <span class="nv">true</span> <span class="p">}</span> <span class="p">})</span>
</code></pre><p>Finally if we want to <strong>only</strong> concern ourselves with channel one we can <code>solo</code> it</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">toggle</span> <span class="nv">mixer</span> <span class="p">{</span> <span class="nv">in-channel-one</span> <span class="p">{</span> <span class="ss">:solo</span>  <span class="nv">true</span> <span class="p">}</span> <span class="p">})</span>
</code></pre><p>You'll notice I didn't set <code>:pause</code> back to <code>false</code> because soloed channels ignore their other properties..</p><h2>Summing Up</h2><p>We covered both the <code>merge</code> and <code>mix</code> methods of <code>core.async</code>. Both methods are higher level ways to combine and control multiple input channels into a single unified output channel.</p><p><code>merge</code> offers a simple straigthforward way to combine channels but offers you little control after the fact. <code>mix</code> gives you greater control over the input channels and is exceptionally useful when you need to manage input streams.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2014%2F06%2F01%2Fcombining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix%2F&amp;text=Combining%20%26%20Controlling%20Channels%20with%20core.async%27s%20merge%20and%20mix&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="01-06-2014" itemprop="datePublished">June 01, 2014</time></div><div class="categories">Published in <a href="/categories/clojure/">Clojure</a> <a href="/categories/clojurescript/">ClojureScript</a> on June 01, 2014</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
