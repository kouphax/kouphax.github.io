<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Yesql - SQL in SQL in Clojure" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Yesql - SQL in SQL in Clojure</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Yesql - SQL in SQL in Clojure</h1><div class="post" itemprop="articleBody"><blockquote><p>Fair warning. This was initially a transcript for a yesql screencast I intended to do but time is dragging on and I really can't see myself getting to that any time soon.</p><p>Why does this matter?</p><p>Well I wouldn't be surprised if this reads pretty much like the yesql README.md with some minor embellishments here and there (and perhaps some opinion). But I'm putting it out there just, well, just because. Yesql is lovely and consider this a tribute of sorts.</p>
</blockquote><p><a href="https://github.com/krisajenkins/yesql">Yesql</a> is a Clojure library for accessing SQL capable databases using SQL. Unlike its contemporaries yesql, as the name alludes to, embraces SQL. The argument here is why create a DSL, no matter how beautifully crafted, when we already have a perfect DSL already in the form of SQL.</p><p>To go a bit further lets look at the rationale in yesql's own README.</p><p>You could write your data access like this, as embedded SQL strings,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">query</span> <span class="s">"SELECT * FROM users WHERE country_code = ?"</span> <span class="s">"GB"</span><span class="p">)</span>
</code></pre><p>But this doesn't scale very well,</p>
<ul>
  <li>commands can get scattered about the code base,</li>
  <li>its hard to see syntax errors, and,</li>
  <li>longer statements can be difficult to read without any sort of syntax highlighting.</li>
</ul><p>The next logical step taken to solve this problem is by adding an additional layer of abstraction. Language specific DSLs are created to dynamically build SQL.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nb">select </span><span class="ss">:*</span>
        <span class="p">(</span><span class="nf">from</span> <span class="ss">:users</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">where</span> <span class="p">(</span><span class="nb">= </span><span class="ss">:country_code</span> <span class="s">"GB"</span><span class="p">)))</span>
</code></pre><p>The benefit these DSLs have is that they remove the need to know the specific dialect of SQL you're using. As each database has a slightly different SQL dialect you simply specify an adapter, such as PostgresAdapater) and the translated SQL will magically be Postgres compatible. Moving to a different database engine is a matter of specifying a new adapter with no code changes.</p><p>Sounds good right? Well not quite - as with almost all abstractions they start to break down when you tread off the happy path.</p><p>Every database system will likely have additional, non-core features, that you'll probably want to exploit, in fact these features are usually factored into selection criteria when you were deciding what to use. Postgres array and JSON data types are a good example of this. These are features that your clever DSL abstraction can't support without extra wrangling because they address the generality of problems. Suddenly you're back to writing raw sql for some of the queries and we are back where we started.</p><p>Yesql tackles these problems by putting SQL in SQL files and allows you to reference these blobs of SQL as clojure functions. So you'll lose the ability to execute the same code across different databases, which if my experience is anything to go by isn't the worst thing that can happen, but you'll gain better editor support, correct syntax highlighting and one less abstraction to ruin your mood.</p><p>Seeing it in action is the best way to demonstrate its simple but powerful api. We'll start by cloning a ready rolled project template</p>
<pre class="highlight"><code>git clone -b 00-starting-point git@github.com:yobriefcasts/007-yesql.git
</code></pre><p>This is nothing more than a project generated by <code>lein new</code> with 2 dependencies added,</p>
<ul>
  <li>One is the Yesql library dependency itself, currently at version 0.4.0, and</li>
  <li>The other is the h2 database driver which we will use as our database in these examples</li>
</ul><p>Finally we have a file based h2 database instance which is pre-populated with a people table containing a few rows of dummy data.</p>
<pre class="highlight"><code>1	James	Hughes	james@yobriefca.se
2	Emma	Hughes	emma@yobriefca.se
3	Ollie	Hughes	ollie@yobriefca.se
4	Nate	Hughes	nate@yobriefca.se
</code></pre><h2>The First Query</h2><p>So lets get this data out of the database.</p><p>As is common across most SQL based libraries in Clojure Yesql derives its connections from a <code>db-spec</code>. This is the same <code>db-spec</code> map you'd pass Clojure's JDBC library or even korma. I'll provide <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">a link</a> to the relevant documentation if you want more information.</p><p>The <code>db-spec</code> required to connect to the current h2 database is already defined in the <code>core.clj</code> file.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span> <span class="p">{</span><span class="ss">:classname</span>    <span class="s">"org.h2.Driver"</span>
              <span class="ss">:subprotocol</span>  <span class="s">"h2"</span>
              <span class="ss">:subname</span>      <span class="s">"./resources/demo.db"</span>
              <span class="ss">:user</span>         <span class="s">"sa"</span>
              <span class="ss">:password</span>     <span class="s">""</span> <span class="p">})</span>
</code></pre><p>So now if we want to create a SQL file <code>get-all-people.sql</code> under the <code>src/sql</code> directory we can write a simple <code>select *</code> statement from the <code>people</code> table.</p>
<pre class="highlight"><code class="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">people</span>
</code></pre><p>Its worth noting that the <code>sql</code> folder name isn't necessary I simply used it for neatness. By default when calling <a href="https://github.com/krisajenkins/yesql">Yesql</a> - paths will be relative to the <code>src</code> directory so you can organise it however you want.</p><p>Now we need to call this from our code. You'll notice in <code>core.clj</code> that I have already included a single require for <code>defquery</code> from the <code>yesql.core</code> namespace.</p><p><code>defquery</code> is one of the 2 macros that gives you an entry point into <a href="https://github.com/krisajenkins/yesql">Yesql</a>, we will get to the other one shortly. <code>defquery</code> takes a name and a path to the query file. This allows <code>defquery</code> to parse the SQL file, convert it into a callable function and define a <code>var</code> based on the name you've given it.</p><p>We can define our <code>get-all-people</code> query like so,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">defquery</span> <span class="nv">get-all-people</span> <span class="s">"sql/get-all-people.sql"</span><span class="p">)</span>
</code></pre><p>Although I've kept them the same the name of the file and the query name don't need to match. If we evaluate this line now we get back our <code>def</code>'d function. Subsequent evaluations, for example if you've changed the contents of the SQL, will result in the <code>def</code> being redefined.</p><p>If we call our new function as-is we'll get an error.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">get-all-people</span><span class="p">)</span>
</code></pre><p>This is because we also need to supply the <code>db-spec</code> that was already defined for us. If we call the function correctly we should see our results.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">get-all-people</span> <span class="nv">db-spec</span><span class="p">)</span>
</code></pre><p>Lets give our output a bit more structure. We can import <code>clojure.pprint</code>s <code>pprint</code> function</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">yesql-tinkering.core</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">yesql.core</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">defquery</span><span class="p">]]</span>
            <span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">pprint</span><span class="p">]]))</span>
</code></pre><p>And run our query again.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">get-all-people</span> <span class="nv">db-spec</span><span class="p">))</span>
</code></pre><h2>Passing data to queries</h2><p>Executing static SQL isn't going to get you very far, if it does and you are only writing read-only systems with ready rolled queries - can I please come work with you? At the very least your queries often require <code>WHERE</code> clauses that need to take values based on some user input from outside the database.</p><p>To demonstrate how we do this in <a href="https://github.com/krisajenkins/yesql">Yesql</a> lets add a new query that filters by surname. We can start by creating a new SQL file <code>src/sql/get-people-by-surname.sql</code> and write our query. As with most frameworks that make use of parameterised queries we put token in place of the value we want to pass in, in the case of Yesql this can be a keyword that will associate a descriptive name against the argument..</p>
<pre class="highlight"><code class="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">people</span> <span class="k">where</span> <span class="n">last_name</span> <span class="o">=</span> <span class="p">:</span><span class="n">last_name</span>
</code></pre><p>Next we can use the defquery macro to "realise" this query.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">defquery</span> <span class="nv">get-people-by-surname</span> <span class="s">"sql/get-people-by-surname.sql"</span><span class="p">)</span>
</code></pre><p>We can call this as we previous did except we need to pass it an argument for last_name.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">get-people-by-surname</span> <span class="nv">db-spec</span> <span class="s">"Hughes"</span><span class="p">))</span>
</code></pre><h2>Documentation</h2><p>Lets diverge a little from our path. Imagine a more complex SQL statement that accepts more than one argument, lets say it has a very domain specific name like <code>isolate_aggregated_upstream_resources</code> - how would you 1. find out what this statement does and 2. how you would call it correctly? Well most obviously you could simply look at the SQL and work it out but that's not really an effective way to go about things.</p><p>In out last example SQL statement we used a parameter name of last_name, well this wasn't just for fun, if well look at the documentation for our query we can see that the parameter name is used as an argument name to our function</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">clojure.repl/doc</span> <span class="nv">get-people-by-surname</span><span class="p">)</span>
</code></pre><p>This is handy but we can go one step further and supply <code>doc</code> compatible documentation in our SQL in the form of comments. By prepending a comment on top of our SQL we can dive into supplying additional commentary around what this SQL is actually doing.</p>
<pre class="highlight"><code class="sql"><span class="c1">-- Find all people for a given surname</span>
</code></pre><p>If we evaluate our <code>defquery</code> again and look at the function signature we should see our comment available as a docstring.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">clojure.repl/doc</span> <span class="nv">get-people-by-surname</span><span class="p">)</span>

<span class="nv">yesql-tinkering.core/get-people-by-surname</span>
<span class="p">([</span><span class="nv">db</span> <span class="nv">last_name</span><span class="p">])</span>
  <span class="nv">Find</span> <span class="nv">all</span> <span class="nv">people</span> <span class="nb">for </span><span class="nv">a</span> <span class="nv">given</span> <span class="nv">surname</span>
</code></pre><h2>Grouping queries</h2><p>The one file per query thing is all well and good until it isn't. You could rather quickly end up with a raft of folders with 3 or 4 queries each which is a bit of a pants way of arranging things.</p><p>Yesql provides a way to group similar queries in a single file, well they don't <strong>have</strong> to be similar but lets assume we have some logical grouping here.</p><p>So lets add a few accessor methods for getting people out of our database. If we create a SQL file <code>src/sql/get-persons.sql</code> and add 2 queries, one for getting a user by ID and another for getting a user by email address. When you use <code>defquery</code> you specify the name of the function in the declaration and the entire file is used as a basis for the query however when we are defining multiple queries at once we need both logically separate the queries in the file and associate a name with each one. We do this by adding a structured comment above each query starting with <code>name:</code> and followed by the name you want to refer to the query as in your code.</p>
<pre class="highlight"><code class="sql"><span class="c1">-- name: get-person-by-id</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">people</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">id</span>

<span class="c1">-- name: get-person-by-email</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">people</span> <span class="k">where</span> <span class="n">email_address</span> <span class="o">=</span> <span class="p">:</span><span class="n">email_address</span>
</code></pre><p>To define these queries in our code we need to import the other macro in <code>yesql</code>s arsenal <code>defqueries</code>. We can then use this to import our queries,</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">defqueries</span> <span class="s">"sql/get-persons.sql"</span><span class="p">)</span>
</code></pre><p>You'll notice that <code>defqueries</code> returns a vector of the defined functions and we can see our two function handles. We can call each of these in the usual way.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">get-person-by-id</span> <span class="nv">db-spec</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">get-person-by-email</span> <span class="nv">db-spec</span> <span class="s">"james@yobriefca.se"</span><span class="p">)</span>
</code></pre><h2>Non-Queries</h2><p>We've still only dealt with querying our database but most systems usually need to manipulate the contained data by either writing new rows or updating and deleting existing rows.</p><p>Rather than add a new set of macros - <a href="https://github.com/krisajenkins/yesql">yesql</a> uses naming conventions to signal to the macros that the operation is a non-query operation.</p><p>For example if we create a SQL file containing a statement for inserting a new user that expects <code>first_name</code>, <code>last_name</code> and <code>email_address</code>, the database will auto generate our ID value.</p>
<pre class="highlight"><code class="sql"><span class="k">insert</span> <span class="k">into</span> <span class="n">people</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">email_address</span><span class="p">)</span>
<span class="k">values</span><span class="p">(:</span><span class="n">first_name</span><span class="p">,</span> <span class="p">:</span><span class="n">last_name</span><span class="p">,</span> <span class="p">:</span><span class="n">email_address</span><span class="p">)</span>
</code></pre><p>We can use <code>defquery</code> again to create our function except this time we prepend the name with an exclamation mark. This is the marker to tell yesql that this is a statement rather than a query.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">defquery</span> <span class="nv">insert-person!</span> <span class="s">"sql/insert-person.sql"</span><span class="p">)</span>
</code></pre><p>The function expects the usual <code>db-spec</code> object as well as our arguments</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">clojure.repl/doc</span> <span class="nv">insert-person!</span><span class="p">)</span>
</code></pre><p>And we can call it in the normal way.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">insert-person!</span> <span class="nv">db-spec</span> <span class="s">"Bill"</span> <span class="s">"Thompson"</span> <span class="s">"bill@thompson.com"</span><span class="p">)</span>
</code></pre><p>This style can be used with any non-query statement such as <code>create</code>, <code>update</code>, <code>delete</code>, <code>alter</code> and all those other statements your database engine supports.</p><p>Statements will return the number of rows affected by default however in the case of insert statements against tables that have auto-generated ids you may want the id of the newly inserted row returned instead. You can achieve this in <a href="https://github.com/krisajenkins/yesql">yesql</a> with the less than exclamation (<code>&lt;!</code>) instead. If we we redefine our <code>insert-person!</code> function to use this we can see that it will return a different set of information</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">defquery</span> <span class="nv">insert-person&lt;!</span> <span class="s">"sql/insert-person.sql"</span><span class="p">)</span>

<span class="p">(</span><span class="nf">insert-person&lt;!</span> <span class="nv">db-spec</span> <span class="s">"Emma"</span> <span class="s">"Thompson"</span> <span class="s">"emma@thompson.com"</span><span class="p">)</span>
</code></pre><p>What is actually returned depends on the database engine, h2 returns a map containing the id but some engines return the full row.</p><h2>Wrap Up</h2><p>Thats just about covers the main features of <a href="https://github.com/krisajenkins/yesql">yesql</a> which as you can see is a neat little solution to bridging the gap between the database and your code. It avoids all the normal pain of wrangling with other peoples conventions and leaky abstractions and allows you to use SQL directly which is a much better medium to express queries against relational data stores.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2014%2F11%2F25%2Fyesql-sql-in-sql-in-clojure%2F&amp;text=Yesql%20-%20SQL%20in%20SQL%20in%20Clojure&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="25-11-2014" itemprop="datePublished">November 25, 2014</time></div><div class="categories">Published in <a href="/categories/clojure/">Clojure</a> on November 25, 2014</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
