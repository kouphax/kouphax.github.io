<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Refactoring Pattern Matching in Scala" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Refactoring Pattern Matching in Scala</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Refactoring Pattern Matching in Scala</h1><div class="post" itemprop="articleBody"><p>I want to take a look at making effective use of Scala's pattern matching capabilities for a fairly trivial example. Don't expect any of this to be mind blowing but maybe you're venturing in Scala for the first time or have been tinkering for a while you might find this useful. </p><p>The example I give below has been taken from a real world example but the context has been changed and made bit more trivial and non-specific.</p><h2>Setting the stage</h2><p>We have a solution by which a customer can place an order through our system. They can pay by various means - Credit Card, Bitcoin and Direct Debit. Once they have placed their order they are taken to a payment selection screen where they can select how they want to pay. Finally, once they have selected their payment method they are redirected to the appropriate payment gateway.</p><p>First lets model the <code>PaymentMethod</code> types</p>
<pre class="highlight"><code class="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">PaymentMethod</span>

<span class="k">object</span> <span class="nc">PaymentMethod</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Card</span> <span class="k">extends</span> <span class="nc">PaymentMethod</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Bitcoin</span> <span class="k">extends</span> <span class="nc">PaymentMethod</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">DirectDebit</span> <span class="k">extends</span> <span class="nc">PaymentMethod</span>
<span class="o">}</span>
</code></pre><p>This gives us case objects that represent the payment types our system supports. Next lets create an <code>Order</code> class to model our actual order.</p>
<pre class="highlight"><code class="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Order</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">total</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">,</span> <span class="n">selectedPaymentMethod</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">PaymentMethod</span><span class="o">])</span>
</code></pre><p>This class has some properties relating to the order</p>
<ol>
  <li>An <code>id</code> property, and</li>
  <li>A <code>total</code> property that holds the final price of the order.</li>
</ol><p>It also has the <code>selectedPaymentMethod</code> property which is an option of our <code>PaymentMethod</code> type. It is defined as an <code>Option</code> because prior to payment selection we will have an order but no payment method selected.</p><p>Now lets assume our system is an event based system. Once payment select has been made the <code>Order</code> instance is persisted to a data store with the chosen option and a system event is triggered to being processing payment and routing the customer.</p><p>Within whatever event handling strategy we use (Actor, Queue, Bus, Callback etc.) we then need to retrieve the customers most recent order and if there is a payment method defined route to the correct payment gateway. We have defined a method like for retrieving the mot recent customer order, </p>
<pre class="highlight"><code class="scala"><span class="k">def</span> <span class="n">mostRecentCustomerOrder</span><span class="o">(</span><span class="n">customerId</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Order</span><span class="o">]</span>
</code></pre><p>It returns a <code>Option[Order]</code> because there are situations where this is used and the customer doesn't yet have a recent order. Just go with it.</p><h2>Decisions using pattern matching</h2><p>Now to the juicy bit. Given we've got the most recent order we need to route accordingly. At this point we want to return yet another <code>Option</code> this time of a potential <code>Route</code> which is an abstraction that allows us to route to external systems (the details are really not important for this example).</p>
<ul>
  <li>If there is no order we return <code>None</code></li>
  <li>If there is an order but no selected payment method we return <code>None</code></li>
  <li>If there is an order and a selected method we return a <code>Some</code> of a route depending on what the select method is.</li>
</ul><p>Lets code this up.</p>
<pre class="highlight"><code class="scala"><span class="n">mostRecentCustomerOrder</span><span class="o">(</span><span class="n">customerId</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">order</span><span class="o">)</span> <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">selectedPaymentMethod</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Card</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToPaymentGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">order</span><span class="o">)</span> <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">selectedPaymentMethod</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Bitcoin</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToBitcoinGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">order</span><span class="o">)</span> <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">selectedPaymentMethod</span> <span class="o">==</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">DirectDebit</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToBankGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre><p>I see this code a lot. It's not necessarily wrong but it is rather long winded. We are doing some things unnecessarily. For example, we are extracting the <code>Order</code> into an <code>order</code> value and inspecting the contents. Not a major issue but we aren't actually using it inside the case statements body. We also run the risk of shadowing other values of the same name.</p><h2>Deeper matching</h2><p>Pattern matching in Scala isn't confined to the top level class. It is entirely possible to match all the way down the object graph. So lets revisit the same bit of code and remove the unnecessary extraction of a value and just use pure matching.</p>
<pre class="highlight"><code class="scala"><span class="n">mostRecentCustomerOrder</span><span class="o">(</span><span class="n">customerId</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Card</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToPaymentGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Bitcoin</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToBitcoinGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">DirectDebit</span><span class="o">)))</span> <span class="k">=&gt;</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">redirectToBankGateway</span><span class="o">())</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre><p>In this case we avoid extracting the <code>order</code> value and make each <code>case</code> a bit more succinct by matching purely on the existence of a <code>PaymentMethod</code> within the <code>Option</code>. We also use <code>_</code> to mark values we aren't interested in. Whether or not this is easier to read than the previous example is very subjective. I think it is but only really marginally so.</p><h2>Option.collect</h2><p>There is another option (pun intended). As <code>mostRecentCustomerOrder</code> returns an <code>Option</code> and we are expected to return an <code>Option</code> we can use <code>Option.collect</code>. </p>
<blockquote>
  <pre class="highlight"><code class="scala"><span class="n">collect</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">pf</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre>
  <pre class="highlight"><code>Returns a scala.Some containing the result of applying pf
to this scala.Option's contained value, if this option is
nonempty and pf is defined for that value.
</code></pre>
</blockquote><p>This gives us the power of pattern matching so we can transform the input <code>Option</code> in to what we want <strong>if and only if</strong> the input satisfies our conditions, falling back to <code>None</code> if it doesn't. You can think of <code>collect</code> like a conditional <code>map</code></p>
<pre class="highlight"><code class="scala"><span class="n">mostRecentCustomerOrder</span><span class="o">(</span><span class="n">customerId</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Card</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">redirectToPaymentGateway</span><span class="o">()</span>
  <span class="k">case</span> <span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">Bitcoin</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">redirectToBitcoinGateway</span><span class="o">()</span>
  <span class="k">case</span> <span class="nc">Order</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">PaymentMethod</span><span class="o">.</span><span class="nc">DirectDebit</span><span class="o">))</span> <span class="k">=&gt;</span>
  	<span class="n">redirectToBankGateway</span><span class="o">()</span>
<span class="o">}</span>
</code></pre><p>By using <code>collect</code> we don't need to provide the default fallback case of returning <code>None</code> plus we get to unwrap all those <code>Some(Order(...))</code> cases as well as not having to wrap each cases return value in a <code>Some</code>. </p><p>Again this is purely personal opinion but this reduction of noise makes this code much easier to read. We are letting the language deal with the default cases without having to repeat ourselves.</p><h2>Summary</h2><p>None (pun intended) of the options (pun intended) above are necessarily wrong and one approach may fit better in some scenarios than another but I feel that laying out the options (pun intended) helps us make more informed decisions while we try and build quality code.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2015%2F12%2F21%2Frefactoring-pattern-matching-in-scala%2F&amp;text=Refactoring%20Pattern%20Matching%20in%20Scala&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="21-12-2015" itemprop="datePublished">December 21, 2015</time></div><div class="categories">Published in <a href="/categories/scala/">Scala</a> on December 21, 2015</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
