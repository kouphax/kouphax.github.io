<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, user-scalable=no" name="viewport"><meta content="Zombie Dice Score Card with Reagent" name="description"><link href="/favicon.ico" rel="shortcut icon" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Merriweather:400,700|Open+Sans:400,700" rel="stylesheet" type="text/css"><link href="/bundles/84cd5d4454d9/styles.css" rel="stylesheet" /><title>Zombie Dice Score Card with Reagent</title></head><body><div class="row"><blockquote class="warning">This post is over 6 months old.  Some details,
       especially technical, may have changed.</blockquote><div itemscope="" itemtype="http://schema.org/Article"><h1 itemprop="name">Zombie Dice Score Card with Reagent</h1><div class="post" itemprop="articleBody"><p>Over the weekend I built a <a href="/zombie-dice">Zombie Dice Score Card</a>. I built it because I keep forgetting to get pen and paper for keeping score but mostly because I wanted to build something simple in ClojureScript again.</p><p><img src="/images/blog/zombie-dice.png" alt="Zombie Dice Score Card" _="_" /></p><p>The app is pretty basic, no server side interaction, no local storage interaction and only a few basic actions/features. You simply,</p>
<ol>
  <li>Add players</li>
  <li>Play zombie dice as usual, rewarding points by clicking the necessary brain on the screen.</li>
  <li>When someone reaches 13 brains you'll be told to finish the round (all remaining players yet to go on this round have a final chance at stealing the win)</li>
  <li>Hitting 'Finish Game' will reward the person with the highest number of brains a gold brain and the next game begins.</li>
  <li>At any time you can reset the current game scores or clear the entire board.</li>
</ol><p>For the curious the stack used is as follows,</p>
<ul>
  <li>ClojureScript</li>
  <li><a href="https://github.com/martinklepsch/tenzing">Tenzing</a> - Leiningen template for creating Boot powered client side only ClojureScript applications.</li>
  <li><a href="http://boot-clj.com/">Boot</a> - The new build system on the Clojure(Script) block offering a more programatic approach to build systems (i.e more like Rake than Maven)</li>
  <li><a href="http://reagent-project.github.io/">Reagent</a> - A simple ClojureScript wrapper around <a href="http://facebook.github.io/react/">React</a>.</li>
  <li><a href="https://github.com/lbradstreet/cljs-uuid-utils">cljs-uuid-utils</a> - ClojureScript library for generating and working with UUID's</li>
</ul><h2>Tenzing</h2><p>This is a nice little template for prototyping with ClojureScript or in situations where you can integrate with external services for your server side needs. It's a conditional template that lets you add technologies that you think you'll need. For example I generated the Zombie Dice Score Card project with,</p>
<pre class="highlight"><code>lein new tenzing zombie-dice +sass +reagent +divshot
</code></pre><p>This template gives me an app with <code>SASS</code>, <code>Reagent</code> and <a href="https://divshot.com/">Divshot</a> configuration and all the necessary build pipeline stuff set up to compile CLJS and SASS when files change. I didn't use <a href="https://divshot.com/">Divshot</a> this time around but it's nice to know the option was there.</p><p>On another note I did find it a bit weird using Leiningen to generate a Boot application but I guess most Clojure(Script) developers are going to have Leiningen available and Boot doesn't provide templating support.</p><h2>Boot</h2><p>I didn't need to dive into Boot too much for this tiny project but I do like what I see. The way tasks are defined in Clojure and composed into pipelines using standard Clojure idioms makes creating build pipelines really rather nice.</p>
<pre class="highlight"><code class="clojure"><span class="p">(</span><span class="nf">deftask</span> <span class="nv">build</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">comp </span><span class="p">(</span><span class="nf">speak</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">cljs</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">sass</span> <span class="ss">:output-dir</span> <span class="s">"css"</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">deftask</span> <span class="nv">run</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">comp </span><span class="p">(</span><span class="nf">serve</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">watch</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">cljs-repl</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">reload</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">build</span><span class="p">)))</span>
</code></pre><p>You see <code>run</code> composes a pipeline of other tasks for serving the application, watching for filesystem changes, connecting to a ClojureScript REPL and reloading the application. It then composes another defined task for building the ClojureScript and SASS.</p><h2>Reagent</h2><p>Aside from a name change Reagent (formerly Cloact) hasn't really change that much since I talked about in <a href="https://yobriefca.se/blog/2014/01/18/adventures-in-clojure-land/">January 2014</a>. Sure they've added some new features and refined the API a bit but its approach is still the same. It provides simple approach to using React in a ClojureScript app offering us hiccup style syntax for declaring components along side atoms for state management.</p><p>I've never really looked into the other React wrappers so I can't speak to whether Reagent is the best but I can say it's certainly been a pleasure to use on small scale apps.</p><h2>Source</h2><p>The source for the app is available, as always, on <a href="https://github.com/kouphax/zombie-dice/">Github</a> and I welcome any feedback or advice you may have.</p><h2>Plans</h2><p>I think I'm going to write this in Elm just to see what all the fuss is about. Maybe add some local storage for saving historical games and players. Truth be told I'll probably never touch it again but a man can dream.</p><h2>Footnote</h2><p>Have you ever played <a href="http://www.sjgames.com/dice/zombiedice/">Zombie Dice</a>? If not you should give it a go it's a simple, quick dice based game that you can explain in about 3 minutes and have a full game done in about 15 or 20 minutes. The aim is simple, try and collect/eat 13 brains by rolling dice over a series of rounds. Once someone hits 13 brains everyone finishes that round and the person that has the highest score wins that game. Typically you play best of 3 or 5 games.</p></div><a class="twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fyobriefca.se%2Fblog%2F2015%2F07%2F20%2Fzombie-dice-score-card-with-reagent%2F&amp;text=Zombie%20Dice%20Score%20Card%20with%20Reagent&amp;via=kouphax" itemprop="discussionUrl" target="_blank">Tweet This</a><div class="dater"><time datetime="20-07-2015" itemprop="datePublished">July 20, 2015</time></div><div class="categories">Published in <a href="/categories/clojure/">Clojure</a> <a href="/categories/clojurescript/">ClojureScript</a> on July 20, 2015</div></div></div><div class="homer"><a href="/"><i class="icon-briefcase" style="font-size:32px;"></i></a></div></body></html>
